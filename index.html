<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>動画からGIFアニメーション変換</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #fafafa;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f5f7ff;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #e8ecff;
        }

        .upload-icon {
            font-size: 48px;
            color: #999;
            margin-bottom: 10px;
        }

        .upload-text {
            color: #666;
            font-size: 16px;
        }

        #fileInput {
            display: none;
        }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
        }
        
        .size-mode-selector {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .size-mode-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        
        .size-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            transition: all 0.3s ease;
        }
        
        .size-input-group {
            display: flex;
            flex-direction: column;
        }
        
        .size-input-group.hidden {
            display: none;
        }
        
        .calculated-value {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }

        .setting-group label {
            color: #555;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-group input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .setting-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .setting-group .hint {
            font-size: 12px;
            color: #999;
            margin-top: 5px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .progress-container {
            display: none;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            margin-top: 10px;
            color: #666;
            font-size: 14px;
            text-align: center;
        }

        .result-container {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
        }

        .result-title {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .result-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #resultGif {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .file-info {
            display: none;
            background: #e8f4ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: #0066cc;
            font-size: 14px;
        }

        .error-message {
            display: none;
            background: #ffe8e8;
            color: #cc0000;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
            position: relative;
            padding-right: 40px;
        }
        
        .error-message .error-close {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-size: 20px;
            color: #cc0000;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .error-message .error-close:hover {
            opacity: 1;
        }
        
        .error-message .error-code {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.8;
        }

        .warning-message {
            display: none;
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .logs-container {
            display: none;
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .logs-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .logs-content {
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            color: #333;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .process-steps {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .step-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            border: 1px solid #667eea;
        }

        .step-item.completed {
            background: #e8f8f5;
            border: 1px solid #4caf50;
        }

        .step-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 14px;
            background: #e0e0e0;
            color: #666;
        }

        .step-item.active .step-icon {
            background: #667eea;
            color: white;
        }

        .step-item.completed .step-icon {
            background: #4caf50;
            color: white;
        }

        .step-text {
            flex: 1;
            font-size: 14px;
            color: #333;
        }

        .palette-preview {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            text-align: center;
        }

        .palette-title {
            font-size: 16px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .palette-image {
            display: inline-block;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .palette-image img {
            display: block;
            width: 256px;
            height: 256px;
            image-rendering: pixelated;
        }

        .palette-info {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }

        .fs-info {
            display: none;
            margin: 10px 0;
            padding: 10px;
            background: #e8f4ff;
            border-radius: 5px;
            font-size: 12px;
            color: #0066cc;
            font-family: 'Courier New', monospace;
        }
        
        .video-preview-container {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
        }
        
        .video-preview-title {
            font-size: 16px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .video-canvas-wrapper {
            position: relative;
            display: inline-block;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            cursor: crosshair;
            margin-bottom: 15px;
        }
        
        .video-canvas {
            display: block;
            width: 100%;
            max-width: 100%;
            height: auto;
            background: #000;
        }
        
        .selection-box {
            position: absolute;
            border: 2px dashed #667eea;
            background: rgba(102, 126, 234, 0.2);
            pointer-events: none;
            display: none;
        }
        
        .selection-handles {
            display: none;
        }
        
        .selection-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #667eea;
            border: 2px solid white;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .selection-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .selection-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .selection-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .selection-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        
        .crop-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .crop-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .crop-input-group label {
            font-size: 12px;
            color: #666;
        }
        
        .crop-input-group input {
            width: 80px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .crop-button {
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            background: #f0f0f0;
            color: #333;
            transition: background 0.2s;
        }
        
        .crop-button:hover {
            background: #e0e0e0;
        }
        
        .crop-button.active {
            background: #667eea;
            color: white;
        }
        
        .video-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .play-button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .play-button:hover {
            background: #5568d3;
        }
        
        .time-display {
            font-size: 14px;
            color: #666;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎬 動画 → GIFアニメーション変換</h1>
        <p class="subtitle">高品質なGIFアニメーションをブラウザ上で生成します（サーバー不要）</p>
        
        <div class="warning-message" id="warningMessage">
            ⚠️ 変換中はブラウザが一時的に固まることがあります。しばらくお待ちください。
        </div>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">📁</div>
            <div class="upload-text">
                クリックして動画ファイルを選択<br>
                またはドラッグ&ドロップ
            </div>
            <input type="file" id="fileInput" accept="video/*">
        </div>

        <div class="file-info" id="fileInfo"></div>
        <div class="error-message" id="errorMessage">
            <div id="errorText"></div>
            <div class="error-code" id="errorCode"></div>
            <span class="error-close" onclick="closeError()">×</span>
        </div>

        <div class="video-preview-container" id="videoPreviewContainer" style="display: none;">
            <div class="video-preview-title">📹 動画プレビュー & 切り出し範囲選択</div>
            <div class="video-canvas-wrapper" id="canvasWrapper">
                <video id="videoPreview" class="video-canvas" controls></video>
                <canvas id="overlayCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none; width: 100%; height: 100%; display: none;"></canvas>
                <div class="selection-box" id="selectionBox">
                    <div class="selection-handles" id="selectionHandles">
                        <div class="selection-handle nw" data-handle="nw"></div>
                        <div class="selection-handle ne" data-handle="ne"></div>
                        <div class="selection-handle sw" data-handle="sw"></div>
                        <div class="selection-handle se" data-handle="se"></div>
                    </div>
                </div>
            </div>
            <div class="crop-controls">
                <button class="crop-button" id="enableCropBtn">✂️ 切り出し範囲を選択</button>
                <button class="crop-button" id="resetCropBtn">リセット</button>
                <div class="crop-input-group">
                    <label>X:</label>
                    <input type="number" id="cropX" value="0" min="0" disabled>
                </div>
                <div class="crop-input-group">
                    <label>Y:</label>
                    <input type="number" id="cropY" value="0" min="0" disabled>
                </div>
                <div class="crop-input-group">
                    <label>幅:</label>
                    <input type="number" id="cropWidth" value="0" min="1" disabled>
                </div>
                <div class="crop-input-group">
                    <label>高さ:</label>
                    <input type="number" id="cropHeight" value="0" min="1" disabled>
                </div>
            </div>
        </div>
        
        <div class="settings" id="timeRangeSettings" style="margin-top: 20px; display: none;">
            <div class="setting-group">
                <label for="startTimeInput">開始時間 (秒)</label>
                <input type="number" id="startTimeInput" value="0" min="0" step="0.1" placeholder="例: 0">
                <span class="hint">動画の開始位置</span>
            </div>
            <div class="setting-group">
                <label for="endTimeInput">終了時間 (秒)</label>
                <input type="number" id="endTimeInput" value="" min="0" step="0.1" placeholder="例: 10">
                <span class="hint">空欄の場合は最後まで</span>
            </div>
            <div class="setting-group">
                <label for="durationDisplay">切り出し時間</label>
                <input type="text" id="durationDisplay" value="全体" disabled style="background-color: #f0f0f0;">
                <span class="hint" id="videoDurationHint">動画の長さ: 未確認</span>
            </div>
        </div>

        <div class="settings" id="sizeAndFpsSettings" style="display: none;">
            <div class="size-mode-selector">
                <label for="sizeMode" style="display: block; margin-bottom: 8px; color: #555; font-size: 14px; font-weight: 500;">
                    サイズ指定方法
                </label>
                <select id="sizeMode">
                    <option value="both">幅と高さを指定する</option>
                    <option value="width">幅を指定する（縦横比維持）</option>
                    <option value="height">高さを指定する（縦横比維持）</option>
                </select>
            </div>
            
            <div class="size-inputs">
                <div class="size-input-group" id="widthGroup">
                    <label for="widthInput">幅 (px)</label>
                    <input type="number" id="widthInput" value="600" placeholder="例: 600" min="1">
                    <span class="calculated-value" id="widthCalculated" style="display: none;"></span>
                </div>
                <div class="size-input-group" id="heightGroup">
                    <label for="heightInput">高さ (px)</label>
                    <input type="number" id="heightInput" value="400" placeholder="例: 400" min="1">
                    <span class="calculated-value" id="heightCalculated" style="display: none;"></span>
                </div>
            </div>
            
            <div class="setting-group" style="margin-top: 20px;">
                <label for="fpsInput">FPS (フレームレート)</label>
                <input type="number" id="fpsInput" value="30" min="1" max="60" placeholder="例: 30">
                <span class="hint">デフォルト: 30</span>
            </div>
        </div>

        <div class="button-group" id="buttonGroup" style="display: none;">
            <button class="btn btn-primary" id="convertBtn" disabled>
                GIFに変換
            </button>
            <button class="btn btn-secondary" id="resetBtn">
                リセット
            </button>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">準備中...</div>
        </div>

        <div class="process-steps" id="processSteps">
            <div class="step-item" id="step1">
                <div class="step-icon">1</div>
                <div class="step-text">ファイルをメモリに読み込み</div>
            </div>
            <div class="step-item" id="step2">
                <div class="step-icon">2</div>
                <div class="step-text">パレット生成中</div>
            </div>
            <div class="step-item" id="step3">
                <div class="step-icon">3</div>
                <div class="step-text">GIFアニメーション変換中</div>
            </div>
            <div class="step-item" id="step4">
                <div class="step-icon">4</div>
                <div class="step-text">結果を準備中</div>
            </div>
        </div>

        <div class="palette-preview" id="palettePreview">
            <div class="palette-title">🎨 生成されたパレット</div>
            <div class="palette-image">
                <img id="paletteImg" alt="パレット画像">
            </div>
            <div class="palette-info" id="paletteInfo"></div>
        </div>

        <div class="fs-info" id="fsInfo"></div>

        <div class="logs-container" id="logsContainer">
            <div class="logs-title">変換ログ</div>
            <div class="logs-content" id="logsContent"></div>
        </div>

        <div class="result-container" id="resultContainer">
            <div class="result-title">✨ 変換完了！</div>
            <div class="result-content">
                <img id="resultGif" alt="変換されたGIF">
                <button class="btn btn-primary" id="downloadBtn">
                    ダウンロード
                </button>
            </div>
        </div>
    </div>

    <!-- FFmpeg.wasm CDN（シングルスレッド版 - バージョン統一） -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js"></script>
    <script>
        (async () => {
            const { createFFmpeg, fetchFile } = FFmpeg;
            
            let ffmpeg = null;
            let isProcessing = false;
            let selectedFile = null;
            let outputBlob = null;

            // DOM要素
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const errorMessage = document.getElementById('errorMessage');
            const warningMessage = document.getElementById('warningMessage');
            const convertBtn = document.getElementById('convertBtn');
            const resetBtn = document.getElementById('resetBtn');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const resultContainer = document.getElementById('resultContainer');
            const resultGif = document.getElementById('resultGif');
            const downloadBtn = document.getElementById('downloadBtn');
            const widthInput = document.getElementById('widthInput');
            const heightInput = document.getElementById('heightInput');
            const fpsInput = document.getElementById('fpsInput');
            const logsContainer = document.getElementById('logsContainer');
            const logsContent = document.getElementById('logsContent');
            const processSteps = document.getElementById('processSteps');
            const palettePreview = document.getElementById('palettePreview');
            const paletteImg = document.getElementById('paletteImg');
            const paletteInfo = document.getElementById('paletteInfo');
            const fsInfo = document.getElementById('fsInfo');
            const sizeMode = document.getElementById('sizeMode');
            const widthGroup = document.getElementById('widthGroup');
            const heightGroup = document.getElementById('heightGroup');
            const widthCalculated = document.getElementById('widthCalculated');
            const heightCalculated = document.getElementById('heightCalculated');
            const startTimeInput = document.getElementById('startTimeInput');
            const endTimeInput = document.getElementById('endTimeInput');
            const durationDisplay = document.getElementById('durationDisplay');
            const videoDurationHint = document.getElementById('videoDurationHint');
            const videoPreviewContainer = document.getElementById('videoPreviewContainer');
            const videoPreview = document.getElementById('videoPreview');
            const overlayCanvas = document.getElementById('overlayCanvas');
            const canvasWrapper = document.getElementById('canvasWrapper');
            const selectionBox = document.getElementById('selectionBox');
            const enableCropBtn = document.getElementById('enableCropBtn');
            const resetCropBtn = document.getElementById('resetCropBtn');
            const cropX = document.getElementById('cropX');
            const cropY = document.getElementById('cropY');
            const cropWidth = document.getElementById('cropWidth');
            const cropHeight = document.getElementById('cropHeight');

            // FFmpeg初期化（真のシングルスレッド版：@ffmpeg/core-st使用）
            async function initFFmpeg() {
                if (!ffmpeg) {
                    // mainName: 'main' が重要：シングルスレッドモードを指定
                    ffmpeg = createFFmpeg({
                        mainName: 'main',  // シングルスレッドモード必須パラメータ
                        corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',
                        log: true
                    });
                    
                    ffmpeg.setLogger(({ type, message }) => {
                        if (message) {
                            console.log(message);
                            appendLog(message);
                        }
                    });
                    
                    ffmpeg.setProgress(({ ratio }) => {
                        const percent = Math.round(ratio * 100);
                        updateProgress(percent, `変換中... ${percent}%`);
                    });
                }
                
                if (!ffmpeg.isLoaded()) {
                    updateProgress(5, 'FFmpeg.wasm（シングルスレッド版）を読み込み中...');
                    await ffmpeg.load();
                    updateProgress(10, 'FFmpeg.wasm（シングルスレッド版）読み込み完了');
                }
            }

            // ログ表示
            function appendLog(message) {
                logsContent.textContent += message + '\n';
                logsContent.scrollTop = logsContent.scrollHeight;
            }

            // エラー表示
            function showError(message, errorObj = null) {
                const errorText = document.getElementById('errorText');
                const errorCode = document.getElementById('errorCode');
                
                errorText.textContent = 'エラーが発生しました。' + message;
                
                if (errorObj) {
                    // エラーコードや詳細情報を表示
                    const errorInfo = [];
                    if (errorObj.code) errorInfo.push(`Code: ${errorObj.code}`);
                    if (errorObj.name) errorInfo.push(`Type: ${errorObj.name}`);
                    if (errorObj.message && errorObj.message !== message) {
                        errorInfo.push(`Details: ${errorObj.message}`);
                    }
                    errorCode.textContent = errorInfo.length > 0 ? errorInfo.join(' | ') : '';
                    errorCode.style.display = errorInfo.length > 0 ? 'block' : 'none';
                } else {
                    errorCode.style.display = 'none';
                }
                
                errorMessage.style.display = 'block';
                // 自動で消さない
            }
            
            // エラーを閉じる
            function closeError() {
                errorMessage.style.display = 'none';
            }
            
            // グローバルに公開（onclick用）
            window.closeError = closeError;

            // ステップ表示更新
            function updateStep(stepNumber, status = 'active') {
                for (let i = 1; i <= 4; i++) {
                    const step = document.getElementById(`step${i}`);
                    if (i < stepNumber) {
                        step.className = 'step-item completed';
                        step.querySelector('.step-icon').textContent = '✓';
                    } else if (i === stepNumber) {
                        step.className = `step-item ${status}`;
                        if (status === 'completed') {
                            step.querySelector('.step-icon').textContent = '✓';
                        }
                    } else {
                        step.className = 'step-item';
                        step.querySelector('.step-icon').textContent = i;
                    }
                }
            }

            // ファイルシステム情報表示
            function showFSInfo(message) {
                fsInfo.textContent = message;
                fsInfo.style.display = 'block';
            }
            
            // 動画のメタデータを保持
            let videoMetadata = {
                width: 600,
                height: 400,
                aspectRatio: 1.5,
                duration: 0
            };
            
            // 切り出し範囲の情報
            let cropData = {
                enabled: false,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                selecting: false,
                startX: 0,
                startY: 0
            };
            
            // サイズモードの切り替え
            function updateSizeMode() {
                const mode = sizeMode.value;
                
                // 表示をリセット
                widthGroup.style.display = 'flex';
                heightGroup.style.display = 'flex';
                widthCalculated.style.display = 'none';
                heightCalculated.style.display = 'none';
                widthInput.disabled = false;
                heightInput.disabled = false;
                
                switch(mode) {
                    case 'width':
                        // 幅を指定（高さは自動計算で表示）
                        heightInput.disabled = true;
                        heightInput.style.backgroundColor = '#f0f0f0';
                        calculateHeightFromWidth();
                        break;
                    case 'height':
                        // 高さを指定（幅は自動計算で表示）
                        widthInput.disabled = true;
                        widthInput.style.backgroundColor = '#f0f0f0';
                        calculateWidthFromHeight();
                        break;
                    case 'both':
                    default:
                        // 両方指定
                        widthInput.style.backgroundColor = 'white';
                        heightInput.style.backgroundColor = 'white';
                        break;
                }
            }
            
            // 幅から高さを計算
            function calculateHeightFromWidth() {
                const width = parseInt(widthInput.value);
                if (!isNaN(width) && width > 0 && videoMetadata.aspectRatio) {
                    const calculatedHeight = Math.round(width / videoMetadata.aspectRatio);
                    heightInput.value = calculatedHeight;
                    heightCalculated.textContent = `縦横比 ${videoMetadata.aspectRatio.toFixed(2)} より自動計算`;
                    heightCalculated.style.display = 'block';
                }
            }
            
            // 高さから幅を計算
            function calculateWidthFromHeight() {
                const height = parseInt(heightInput.value);
                if (!isNaN(height) && height > 0 && videoMetadata.aspectRatio) {
                    const calculatedWidth = Math.round(height * videoMetadata.aspectRatio);
                    widthInput.value = calculatedWidth;
                    widthCalculated.textContent = `縦横比 ${videoMetadata.aspectRatio.toFixed(2)} より自動計算`;
                    widthCalculated.style.display = 'block';
                }
            }
            
            // イベントリスナー
            sizeMode.addEventListener('change', updateSizeMode);
            
            widthInput.addEventListener('input', () => {
                if (sizeMode.value === 'width') {
                    calculateHeightFromWidth();
                }
            });
            
            heightInput.addEventListener('input', () => {
                if (sizeMode.value === 'height') {
                    calculateWidthFromHeight();
                }
            });
            
            // 時間範囲の変更を監視
            function updateDurationDisplay() {
                const startTime = parseFloat(startTimeInput.value) || 0;
                const endTime = parseFloat(endTimeInput.value) || videoMetadata.duration;
                
                if (endTime && endTime > startTime) {
                    const duration = endTime - startTime;
                    durationDisplay.value = `${duration.toFixed(1)}秒 (${startTime.toFixed(1)}秒 〜 ${endTime.toFixed(1)}秒)`;
                } else if (!endTimeInput.value && videoMetadata.duration) {
                    const duration = videoMetadata.duration - startTime;
                    durationDisplay.value = `${duration.toFixed(1)}秒 (${startTime.toFixed(1)}秒 〜 最後まで)`;
                } else {
                    durationDisplay.value = '全体';
                }
            }
            
            startTimeInput.addEventListener('input', updateDurationDisplay);
            endTimeInput.addEventListener('input', updateDurationDisplay);
            
            // 切り出し範囲選択の実装
            let isSelecting = false;
            let selectionStart = {x: 0, y: 0};
            
            enableCropBtn.addEventListener('click', () => {
                cropData.enabled = !cropData.enabled;
                if (cropData.enabled) {
                    enableCropBtn.classList.add('active');
                    enableCropBtn.textContent = '✂️ 選択モード中';
                    canvasWrapper.style.cursor = 'crosshair';
                    overlayCanvas.style.display = 'block';  // オーバーレイを表示
                    
                    // 入力フィールドを有効化
                    cropX.disabled = false;
                    cropY.disabled = false;
                    cropWidth.disabled = false;
                    cropHeight.disabled = false;
                } else {
                    disableCropMode();
                }
            });
            
            resetCropBtn.addEventListener('click', () => {
                resetCropSelection();
            });
            
            function resetCropSelection() {
                cropData.x = 0;
                cropData.y = 0;
                cropData.width = 0;
                cropData.height = 0;
                updateCropInputs();
                selectionBox.style.display = 'none';
                drawOverlay();
                disableCropMode();
            }
            
            function disableCropMode() {
                cropData.enabled = false;
                enableCropBtn.classList.remove('active');
                enableCropBtn.textContent = '✂️ 切り出し範囲を選択';
                canvasWrapper.style.cursor = 'default';
                overlayCanvas.style.display = 'none';  // オーバーレイを非表示
                
                // 入力フィールドを無効化
                cropX.disabled = true;
                cropY.disabled = true;
                cropWidth.disabled = true;
                cropHeight.disabled = true;
            }
            
            // マウスイベントハンドラ
            canvasWrapper.addEventListener('mousedown', (e) => {
                if (!cropData.enabled) return;
                
                const rect = videoPreview.getBoundingClientRect();
                const scaleX = videoPreview.videoWidth / rect.width;
                const scaleY = videoPreview.videoHeight / rect.height;
                
                isSelecting = true;
                selectionStart.x = (e.clientX - rect.left) * scaleX;
                selectionStart.y = (e.clientY - rect.top) * scaleY;
                
                cropData.x = selectionStart.x;
                cropData.y = selectionStart.y;
                cropData.width = 0;
                cropData.height = 0;
            });
            
            canvasWrapper.addEventListener('mousemove', (e) => {
                if (!isSelecting || !cropData.enabled) return;
                
                const rect = videoPreview.getBoundingClientRect();
                const scaleX = videoPreview.videoWidth / rect.width;
                const scaleY = videoPreview.videoHeight / rect.height;
                
                const currentX = (e.clientX - rect.left) * scaleX;
                const currentY = (e.clientY - rect.top) * scaleY;
                
                cropData.x = Math.min(selectionStart.x, currentX);
                cropData.y = Math.min(selectionStart.y, currentY);
                cropData.width = Math.abs(currentX - selectionStart.x);
                cropData.height = Math.abs(currentY - selectionStart.y);
                
                // 境界チェック
                cropData.x = Math.max(0, cropData.x);
                cropData.y = Math.max(0, cropData.y);
                cropData.width = Math.min(cropData.width, videoPreview.videoWidth - cropData.x);
                cropData.height = Math.min(cropData.height, videoPreview.videoHeight - cropData.y);
                
                updateCropInputs();
                updateSelectionBox();
                drawOverlay();
            });
            
            canvasWrapper.addEventListener('mouseup', () => {
                isSelecting = false;
            });
            
            // 選択ボックスの更新
            function updateSelectionBox() {
                if (cropData.width > 0 && cropData.height > 0) {
                    const rect = videoPreview.getBoundingClientRect();
                    const scaleX = rect.width / videoPreview.videoWidth;
                    const scaleY = rect.height / videoPreview.videoHeight;
                    
                    selectionBox.style.display = 'block';
                    selectionBox.style.left = (cropData.x * scaleX) + 'px';
                    selectionBox.style.top = (cropData.y * scaleY) + 'px';
                    selectionBox.style.width = (cropData.width * scaleX) + 'px';
                    selectionBox.style.height = (cropData.height * scaleY) + 'px';
                } else {
                    selectionBox.style.display = 'none';
                }
            }
            
            // 入力フィールドの更新
            function updateCropInputs() {
                cropX.value = Math.round(cropData.x);
                cropY.value = Math.round(cropData.y);
                cropWidth.value = Math.round(cropData.width);
                cropHeight.value = Math.round(cropData.height);
            }
            
            // 入力フィールドからの更新
            [cropX, cropY, cropWidth, cropHeight].forEach(input => {
                input.addEventListener('input', () => {
                    cropData.x = parseInt(cropX.value) || 0;
                    cropData.y = parseInt(cropY.value) || 0;
                    cropData.width = parseInt(cropWidth.value) || 0;
                    cropData.height = parseInt(cropHeight.value) || 0;
                    updateSelectionBox();
                    drawOverlay();
                });
            });
            
            // オーバーレイの描画
            function drawOverlay() {
                const ctx = overlayCanvas.getContext('2d');
                overlayCanvas.width = videoPreview.videoWidth;
                overlayCanvas.height = videoPreview.videoHeight;
                
                if (cropData.enabled && cropData.width > 0 && cropData.height > 0) {
                    // 半透明の黒で全体を覆う
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    
                    // 選択範囲をクリア
                    ctx.clearRect(cropData.x, cropData.y, cropData.width, cropData.height);
                    
                    // 選択範囲の枠線
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(cropData.x, cropData.y, cropData.width, cropData.height);
                } else {
                    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                }
            }
            
            // 動画のサイズ変更時にオーバーレイをリサイズ
            videoPreview.addEventListener('resize', () => {
                const rect = videoPreview.getBoundingClientRect();
                overlayCanvas.style.width = rect.width + 'px';
                overlayCanvas.style.height = rect.height + 'px';
                drawOverlay();
            });
            
            // ウィンドウリサイズ時の処理
            window.addEventListener('resize', () => {
                if (videoPreview.videoWidth) {
                    const rect = videoPreview.getBoundingClientRect();
                    overlayCanvas.style.width = rect.width + 'px';
                    overlayCanvas.style.height = rect.height + 'px';
                    updateSelectionBox();
                }
            });

            // 進捗表示
            function updateProgress(percent, text) {
                progressFill.style.width = percent + '%';
                progressText.textContent = text;
            }

            // ファイル選択
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    selectFile(file);
                }
            });

            // ドラッグ&ドロップ
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    selectFile(file);
                } else {
                    showError('動画ファイルを選択してください');
                }
            });

            // ファイル選択処理
            async function selectFile(file) {
                const MAX_SIZE_MB = 50; // 50MB制限
                const fileSizeMB = file.size / 1024 / 1024;
                
                if (fileSizeMB > MAX_SIZE_MB) {
                    showError(`ファイルサイズが大きすぎます。${MAX_SIZE_MB}MB以下のファイルを選択してください。`, {code: 'FILE_TOO_LARGE', name: 'FileSizeError'});
                    return;
                }
                
                selectedFile = file;
                fileInfo.textContent = `選択されたファイル: ${file.name} (${fileSizeMB.toFixed(2)} MB)`;
                fileInfo.style.display = 'block';
                
                if (fileSizeMB > 10) {
                    fileInfo.textContent += ' ⚠️ 大きいファイルのため、変換に時間がかかります';
                }
                
                // 動画プレビュー用のURLを作成（一度だけ）
                const previewUrl = URL.createObjectURL(file);
                console.log('Preview URL created:', previewUrl);
                
                // UI要素を表示
                videoPreview.src = previewUrl;
                videoPreviewContainer.style.display = 'block';
                document.getElementById('timeRangeSettings').style.display = 'block';
                document.getElementById('sizeAndFpsSettings').style.display = 'block';
                document.getElementById('buttonGroup').style.display = 'flex';
                
                // 動画を再生可能な状態にする
                videoPreview.load();
                
                // 切り出し範囲をリセット
                resetCropSelection();
                
                // プレビュー動画のメタデータを取得
                await new Promise((resolve) => {
                    videoPreview.onloadedmetadata = () => {
                        // 動画の実際のサイズを取得
                        const videoWidth = videoPreview.videoWidth;
                        const videoHeight = videoPreview.videoHeight;
                        const videoDuration = videoPreview.duration;
                        
                        // メタデータを保存
                        videoMetadata.width = videoWidth;
                        videoMetadata.height = videoHeight;
                        videoMetadata.aspectRatio = videoWidth / videoHeight;
                        videoMetadata.duration = videoDuration;
                        
                        // 入力フィールドに設定
                        widthInput.value = videoWidth.toString();
                        heightInput.value = videoHeight.toString();
                        
                        // モードに応じて表示を更新
                        updateSizeMode();
                        
                        fileInfo.textContent = `選択されたファイル: ${file.name} (${fileSizeMB.toFixed(2)} MB) | サイズ: ${videoWidth}x${videoHeight} | 長さ: ${videoDuration.toFixed(1)}秒`;
                        
                        // 動画の長さを表示
                        videoDurationHint.textContent = `動画の長さ: ${videoDuration.toFixed(1)}秒`;
                        
                        // 終了時間のデフォルト値を設定
                        endTimeInput.max = videoDuration.toFixed(1);
                        startTimeInput.max = videoDuration.toFixed(1);
                        
                        // 切り出し時間を更新
                        updateDurationDisplay();
                        
                        // オーバーレイキャンバスのサイズを調整
                        setTimeout(() => {
                            const rect = videoPreview.getBoundingClientRect();
                            overlayCanvas.style.width = rect.width + 'px';
                            overlayCanvas.style.height = rect.height + 'px';
                            drawOverlay();
                        }, 100);
                        
                        resolve();
                    };
                    
                    videoPreview.onerror = () => {
                        // エラーの場合はデフォルト値を使用
                        console.log('プレビュー動画のメタデータ取得失敗、デフォルト値を使用');
                        widthInput.value = '600';
                        heightInput.value = '-1';
                        resolve();
                    };
                    
                    // タイムアウト設定
                    setTimeout(() => {
                        resolve();
                    }, 5000);
                });
                
                convertBtn.disabled = false;
            }

            // 変換処理
            convertBtn.addEventListener('click', async () => {
                if (!selectedFile) {
                    showError('ファイルを選択してください。', {code: 'NO_FILE_SELECTED', name: 'ValidationError'});
                    return;
                }

                if (isProcessing) {
                    showError('現在変換処理中です。しばらくお待ちください。', {code: 'PROCESS_BUSY', name: 'ProcessingError'});
                    return;
                }
                
                isProcessing = true;
                convertBtn.disabled = true;
                progressContainer.style.display = 'block';
                logsContainer.style.display = 'block';
                logsContent.textContent = '';
                resultContainer.style.display = 'none';
                warningMessage.style.display = 'block';
                processSteps.style.display = 'block';
                palettePreview.style.display = 'none';
                fsInfo.style.display = 'none';
                
                // ステップをリセット
                for (let i = 1; i <= 4; i++) {
                    updateStep(i, '');
                }
                
                updateProgress(0, 'FFmpegを初期化中...');

                try {
                    // FFmpeg初期化
                    await initFFmpeg();
                    
                    // ステップ1: ファイル読み込み
                    updateStep(1, 'active');
                    updateProgress(15, 'ファイルを読み込み中...');
                    
                    // ファイルをFFmpegのファイルシステムに書き込み
                    ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(selectedFile));
                    updateStep(1, 'completed');
                    
                    updateProgress(25, '変換準備完了...');
                    
                    // サイズ設定
                    let width = widthInput.value || '600';
                    let height = heightInput.value || '400';
                    const fps = fpsInput.value || '30';
                    
                    // モードに応じてサイズを設定
                    const mode = sizeMode.value;
                    if (mode === 'width') {
                        height = '-1'; // FFmpegに縦横比維持を任せる
                    } else if (mode === 'height') {
                        width = '-1'; // FFmpegに縦横比維持を任せる
                    }
                    
                    const scale = `${width}:${height}`;
                    
                    // 時間範囲の設定
                    const startTime = parseFloat(startTimeInput.value) || 0;
                    const endTime = parseFloat(endTimeInput.value) || null;
                    
                    // FFmpegコマンドの構築
                    const ffmpegArgs = [];
                    
                    // 開始時間の指定（-ss は入力前に指定することで高速化）
                    if (startTime > 0) {
                        ffmpegArgs.push('-ss', startTime.toString());
                    }
                    
                    // 入力ファイル
                    ffmpegArgs.push('-i', 'input.mp4');
                    
                    // 終了時間の指定（durationとして）
                    if (endTime !== null && endTime > startTime) {
                        const duration = endTime - startTime;
                        ffmpegArgs.push('-t', duration.toString());
                    }
                    
                    // ステップ2: パレット生成とGIF変換
                    updateStep(2, 'active');
                    updateProgress(30, 'パレットを生成中...');
                    
                    // 切り出し範囲の設定
                    let cropFilter = '';
                    if (cropData.enabled && cropData.width > 0 && cropData.height > 0) {
                        cropFilter = `crop=${Math.round(cropData.width)}:${Math.round(cropData.height)}:${Math.round(cropData.x)}:${Math.round(cropData.y)},`;
                    }
                    
                    // フィルターとその他のオプションを追加
                    ffmpegArgs.push(
                        '-filter_complex',
                        `[0:v]${cropFilter}fps=${fps},scale=${scale}:flags=lanczos,split[s0][s1];` +
                        `[s0]palettegen[p];` +
                        `[p]split[p1][p2];` +
                        `[s1][p1]paletteuse=dither=bayer:bayer_scale=5:diff_mode=rectangle[gif];` +
                        `[p2]scale=256:256:flags=neighbor[palette_preview]`,
                        '-map', '[gif]', '-y', 'output.gif',
                        '-map', '[palette_preview]', '-frames:v', '1', '-y', 'palette_preview.png'
                    );
                    
                    // 1コマンドでGIFとパレットプレビューを同時生成
                    console.log('FFmpeg command:', ffmpegArgs.join(' '));
                    await ffmpeg.run(...ffmpegArgs);
                    
                    updateStep(2, 'completed');
                    
                    // ファイルシステム情報表示
                    try {
                        const files = ffmpeg.FS('readdir', '/');
                        const fileInfo = files.map(f => {
                            try {
                                const stat = ffmpeg.FS('stat', `/${f}`);
                                return `${f} (${stat.size} bytes)`;
                            } catch {
                                return f;
                            }
                        }).filter(f => !f.startsWith('dev') && !f.startsWith('proc') && !f.startsWith('tmp') && !f.startsWith('home'));
                        showFSInfo('ファイルシステム: ' + fileInfo.join(', '));
                    } catch (e) {
                        console.error('FS info error:', e);
                    }
                    
                    // ステップ3: パレット表示
                    updateStep(3, 'active');
                    updateProgress(60, 'パレットを表示中...');
                    
                    // パレットプレビュー表示
                    try {
                        const paletteData = ffmpeg.FS('readFile', 'palette_preview.png');
                        const paletteBlob = new Blob([paletteData.buffer], { type: 'image/png' });
                        const paletteUrl = URL.createObjectURL(paletteBlob);
                        paletteImg.src = paletteUrl;
                        paletteInfo.textContent = `サイズ: ${paletteData.length} bytes | 256色パレット (16x16ピクセル)`;
                        palettePreview.style.display = 'block';
                    } catch (e) {
                        console.error('Palette preview error:', e);
                    }
                    
                    updateStep(3, 'completed');
                    
                    // ステップ4: GIF生成
                    updateStep(4, 'active');
                    updateProgress(80, 'GIFを準備中...');
                    
                    updateProgress(90, '結果を準備中...');
                    
                    // 結果を読み込み
                    const data = ffmpeg.FS('readFile', 'output.gif');
                    outputBlob = new Blob([data.buffer], { type: 'image/gif' });
                    const url = URL.createObjectURL(outputBlob);
                    
                    // 結果表示
                    resultGif.src = url;
                    resultContainer.style.display = 'block';
                    
                    updateStep(4, 'completed');
                    updateProgress(100, '完了！');
                    
                    // GIFファイル情報表示
                    const gifSize = (data.length / 1024 / 1024).toFixed(2);
                    console.log(`GIFサイズ: ${gifSize} MB`);
                    
                    // クリーンアップ
                    try {
                        ffmpeg.FS('unlink', 'input.mp4');
                        ffmpeg.FS('unlink', 'palette_preview.png');
                        ffmpeg.FS('unlink', 'output.gif');
                    } catch (e) {
                        console.log('Cleanup error:', e);
                    }
                    
                } catch (error) {
                    console.error('変換エラー:', error);
                    showError('変換処理中に問題が発生しました。', error);
                } finally {
                    isProcessing = false;
                    convertBtn.disabled = false;
                    warningMessage.style.display = 'none';
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 2000);
                    
                    // FFmpegインスタンスを終了（次回実行のため）
                    setTimeout(() => {
                        if (ffmpeg && ffmpeg.isLoaded()) {
                            console.log('Terminating FFmpeg instance for next run...');
                            ffmpeg.exit();
                            ffmpeg = null;
                        }
                    }, 3000);  // 少し遅延させてから終了
                }
            });

            // ダウンロード
            downloadBtn.addEventListener('click', () => {
                if (outputBlob) {
                    const url = URL.createObjectURL(outputBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'output.gif';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            });

            // リセット
            resetBtn.addEventListener('click', () => {
                selectedFile = null;
                outputBlob = null;
                fileInput.value = '';
                fileInfo.style.display = 'none';
                resultContainer.style.display = 'none';
                progressContainer.style.display = 'none';
                logsContainer.style.display = 'none';
                warningMessage.style.display = 'none';
                processSteps.style.display = 'none';
                palettePreview.style.display = 'none';
                fsInfo.style.display = 'none';
                // UI要素を非表示
                videoPreviewContainer.style.display = 'none';
                document.getElementById('timeRangeSettings').style.display = 'none';
                document.getElementById('sizeAndFpsSettings').style.display = 'none';
                document.getElementById('buttonGroup').style.display = 'none';
                convertBtn.disabled = true;
                
                // プレビューURLをリボーク
                if (videoPreview.src) {
                    URL.revokeObjectURL(videoPreview.src);
                    videoPreview.src = '';
                }
                
                // 切り出し設定をリセット
                resetCropSelection();
                widthInput.value = '600';
                heightInput.value = '400';
                fpsInput.value = '30';
                sizeMode.value = 'both';
                startTimeInput.value = '0';
                endTimeInput.value = '';
                durationDisplay.value = '全体';
                videoDurationHint.textContent = '動画の長さ: 未確認';
                updateSizeMode();
            });
        })();
    </script>
</body>
</html>